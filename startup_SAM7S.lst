   1              	# 1 "startup_SAM7S.S"
   2              	# 1 "<built-in>"
   1              	/***********************************************************************/
   0              	
   0              	
   2              	/*                                                                     */
   3              	/*  startup_SAM7S.S:  Startup file for Atmel AT91SAM7S device series   */
   4              	/*                                                                     */
   5              	/***********************************************************************/
   6              	/*  ported to arm-elf-gcc / WinARM by Martin Thomas, KL, .de           */
   7              	/*  <eversmith@heizung-thomas.de>                                      */
   8              	/*  modifications Copyright Martin Thomas 2005                         */
   9              	/*                                                                     */
  10              	/*  Based on a file that has been a part of the uVision/ARM            */
  11              	/*  development tools, Copyright KEIL ELEKTRONIK GmbH 2002-2004        */
  12              	/***********************************************************************/
  13              	
  14              	/* 
  15              	  Modifications by Martin Thomas:
  16              	  - added handling of execption vectors in RAM ("ramfunc")
  17              	  - added options to remap the interrupt vectors to RAM
  18              	    (see makefile for switch-option)
  19              	  - replaced all ";" and "#" for comments with // or / *  * /
  20              	  - added C++ ctor handling
  21              	  - .text in RAM for debugging (RAM_RUN)
  22              	*/
  23              	
  24              	
  25              	// mt: this file should not be used with the Configuration Wizard
  26              	// since a lot of changes have been done for the WinARM/gcc example
  27              	/* 
  28              	//*** <<< Use Configuration Wizard in Context Menu >>> ***
  29              	*/
  30              	
  31              	
  32              	
  33              	// *** Startup Code (executed after Reset) ***
  34              	
  35              	
  36              	// Standard definitions of Mode bits and Interrupt (I & F) flags in PSRs
  37              	
  38              	        .equ    Mode_USR,       0x10
  39              	        .equ    Mode_FIQ,       0x11
  40              	        .equ    Mode_IRQ,       0x12
  41              	        .equ    Mode_SVC,       0x13
  42              	        .equ    Mode_ABT,       0x17
  43              	        .equ    Mode_UND,       0x1B
  44              	        .equ    Mode_SYS,       0x1F
  45              	
  46              	        .equ    I_Bit,          0x80    /* when I bit is set, IRQ is disabled */
  47              	        .equ    F_Bit,          0x40    /* when F bit is set, FIQ is disabled */
  48              	
  49              	
  50              	// Internal Memory Base Addresses
  51              	        .equ    FLASH_BASE,     0x00100000   
  52              	        .equ    RAM_BASE,       0x00200000
  53              	
  54              	
  55              	/*
  56              	// <h> Stack Configuration
  57              	//   <o>  Top of Stack Address  <0x0-0xFFFFFFFF:4>
  58              	//   <h>  Stack Sizes (in Bytes)
  59              	//     <o1> Undefined Mode      <0x0-0xFFFFFFFF:4>
  60              	//     <o2> Supervisor Mode     <0x0-0xFFFFFFFF:4>
  61              	//     <o3> Abort Mode          <0x0-0xFFFFFFFF:4>
  62              	//     <o4> Fast Interrupt Mode <0x0-0xFFFFFFFF:4>
  63              	//     <o5> Interrupt Mode      <0x0-0xFFFFFFFF:4>
  64              	//     <o6> User/System Mode    <0x0-0xFFFFFFFF:4>
  65              	//   </h>
  66              	// </h>
  67              	*/
  68              	        .equ    Top_Stack,      0x00204000
  69              	        .equ    UND_Stack_Size, 0x00000004
  70              	        .equ    SVC_Stack_Size, 0x00000100
  71              	        .equ    ABT_Stack_Size, 0x00000004
  72              	        .equ    FIQ_Stack_Size, 0x00000004
  73              	        .equ    IRQ_Stack_Size, 0x00000100
  74              	        .equ    USR_Stack_Size, 0x00000400
  75              	
  76              	
  77              	// Embedded Flash Controller (EFC) definitions
  78              	        .equ    EFC_BASE,       0xFFFFFF00  /* EFC Base Address */
  79              	        .equ    EFC_FMR,        0x60        /* EFC_FMR Offset */
  80              	
  81              	/*
  82              	// <e> Embedded Flash Controller (EFC)
  83              	//   <o1.16..23> FMCN: Flash Microsecond Cycle Number <0-255>
  84              	//               <i> Number of Master Clock Cycles in 1us
  85              	//   <o1.8..9>   FWS: Flash Wait State
  86              	//               <0=> Read: 1 cycle / Write: 2 cycles
  87              	//               <1=> Read: 2 cycle / Write: 3 cycles
  88              	//               <2=> Read: 3 cycle / Write: 4 cycles
  89              	//               <3=> Read: 4 cycle / Write: 4 cycles
  90              	// </e>
  91              	*/
  92              	        .equ    EFC_SETUP,      1
  93              	        .equ    EFC_FMR_Val,    0x00320100
  94              	
  95              	
  96              	// Watchdog Timer (WDT) definitions
  97              	        .equ    WDT_BASE,       0xFFFFFD40  /* WDT Base Address */
  98              	        .equ    WDT_MR,         0x04        /* WDT_MR Offset */
  99              	
 100              	/*
 101              	// <e> Watchdog Timer (WDT)
 102              	//   <o1.0..11>  WDV: Watchdog Counter Value <0-4095>
 103              	//   <o1.16..27> WDD: Watchdog Delta Value <0-4095>
 104              	//   <o1.12>     WDFIEN: Watchdog Fault Interrupt Enable
 105              	//   <o1.13>     WDRSTEN: Watchdog Reset Enable
 106              	//   <o1.14>     WDRPROC: Watchdog Reset Processor
 107              	//   <o1.28>     WDDBGHLT: Watchdog Debug Halt
 108              	//   <o1.29>     WDIDLEHLT: Watchdog Idle Halt
 109              	//   <o1.15>     WDDIS: Watchdog Disable
 110              	// </e>
 111              	*/
 112              	        .equ    WDT_SETUP,      1
 113              	        .equ    WDT_MR_Val,     0x00008000
 114              	
 115              	
 116              	// Power Mangement Controller (PMC) definitions
 117              	        .equ    PMC_BASE,       0xFFFFFC00  /* PMC Base Address */
 118              	        .equ    PMC_MOR,        0x20        /* PMC_MOR Offset */
 119              	        .equ    PMC_MCFR,       0x24        /* PMC_MCFR Offset */
 120              	        .equ    PMC_PLLR,       0x2C        /* PMC_PLLR Offset */
 121              	        .equ    PMC_MCKR,       0x30        /* PMC_MCKR Offset */
 122              	        .equ    PMC_SR,         0x68        /* PMC_SR Offset */
 123              	        .equ    PMC_MOSCEN,     (1<<0)      /* Main Oscillator Enable */
 124              	        .equ    PMC_OSCBYPASS,  (1<<1)      /* Main Oscillator Bypass */
 125              	        .equ    PMC_OSCOUNT,    (0xFF<<8)   /* Main OScillator Start-up Time */
 126              	        .equ    PMC_DIV,        (0xFF<<0)   /* PLL Divider */
 127              	        .equ    PMC_PLLCOUNT,   (0x3F<<8)   /* PLL Lock Counter */
 128              	        .equ    PMC_OUT,        (0x03<<14)  /* PLL Clock Frequency Range */
 129              	        .equ    PMC_MUL,        (0x7FF<<16) /* PLL Multiplier */
 130              	        .equ    PMC_USBDIV,     (0x03<<28)  /* USB Clock Divider */
 131              	        .equ    PMC_CSS,        (3<<0)      /* Clock Source Selection */
 132              	        .equ    PMC_PRES,       (7<<2)      /* Prescaler Selection */
 133              	        .equ    PMC_MOSCS,      (1<<0)      /* Main Oscillator Stable */
 134              	        .equ    PMC_LOCK,       (1<<2)      /* PLL Lock Status */
 135              	
 136              	/*
 137              	// <e> Power Mangement Controller (PMC)
 138              	//   <h> Main Oscillator
 139              	//     <o1.0>      MOSCEN: Main Oscillator Enable
 140              	//     <o1.1>      OSCBYPASS: Oscillator Bypass
 141              	//     <o1.8..15>  OSCCOUNT: Main Oscillator Startup Time <0-255>
 142              	//   </h>
 143              	//   <h> Phase Locked Loop (PLL)
 144              	//     <o2.0..7>   DIV: PLL Divider <0-255>
 145              	//     <o2.16..26> MUL: PLL Multiplier <0-2047>
 146              	//                 <i> PLL Output is multiplied by MUL+1
 147              	//     <o2.14..15> OUT: PLL Clock Frequency Range
 148              	//                 <0=> 80..160MHz  <1=> Reserved
 149              	//                 <2=> 150..220MHz <3=> Reserved
 150              	//     <o2.8..13>  PLLCOUNT: PLL Lock Counter <0-63>
 151              	//     <o2.28..29> USBDIV: USB Clock Divider
 152              	//                 <0=> None  <1=> 2  <2=> 4  <3=> Reserved
 153              	//   </h>
 154              	//   <o3.0..1>   CSS: Clock Source Selection
 155              	//               <0=> Slow Clock
 156              	//               <1=> Main Clock
 157              	//               <2=> Reserved
 158              	//               <3=> PLL Clock
 159              	//   <o3.2..4>   PRES: Prescaler
 160              	//               <0=> None
 161              	//               <1=> Clock / 2    <2=> Clock / 4
 162              	//               <3=> Clock / 8    <4=> Clock / 16
 163              	//               <5=> Clock / 32   <6=> Clock / 64
 164              	//               <7=> Reserved
 165              	// </e>
 166              	*/
 167              	        .equ    PMC_SETUP,      1
 168              	        .equ    PMC_MOR_Val,    0x00000601
 169              	        .equ    PMC_PLLR_Val,   0x00191C05
 170              	        .equ    PMC_MCKR_Val,   0x00000007
 171              	
 172              	
 173              	
 174              	
 175              	#if defined(VECTORS_IN_RAM) && defined(ROM_RUN)
 176              	
 177              	/* 
 178              	 Exception Vectors to be placed in RAM - added by mt
 179              	 -> will be used after remapping in ROM_RUN
 180              	 -> not needed for RAM_RUN
 181              	 Mapped to Address 0 after remapping in ROM_RUN
 182              	 Absolute addressing mode must be used.
 183              	 Dummy Handlers are implemented as infinite loops which can be modified.
 184              	 VECTORS_IN_RAM defined in makefile/by commandline 
 185              	*/
 186              				.text
 187              				.arm
 188              				.section .vectram, "ax"
 189              				
 190 0000 18F09FE5 	VectorsRAM:     LDR     PC,Reset_AddrR
 191 0004 18F09FE5 	                LDR     PC,Undef_AddrR
 192 0008 18F09FE5 	                LDR     PC,SWI_AddrR
 193 000c 18F09FE5 	                LDR     PC,PAbt_AddrR
 194 0010 18F09FE5 	                LDR     PC,DAbt_AddrR
 195 0014 0000A0E1 	                NOP                            /* Reserved Vector */
 196 0018 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_IVR */
 197 001c 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_FVR */
 198              	
 199 0020 04000000 	Reset_AddrR:     .word   Reset_Handler
 200 0024 40000000 	Undef_AddrR:     .word   Undef_HandlerR
 201 0028 44000000 	SWI_AddrR:       .word   SWI_HandlerR
 202 002c 48000000 	PAbt_AddrR:      .word   PAbt_HandlerR
 203 0030 4C000000 	DAbt_AddrR:      .word   DAbt_HandlerR
 204              	//               .word   0xdeadbeef     /* Test Reserved Address */
 205 0034 00000000 	                 .word   0     /* Reserved Address */
 206 0038 50000000 	IRQ_AddrR:       .word   IRQ_HandlerR
 207 003c 54000000 	FIQ_AddrR:       .word   FIQ_HandlerR
 208              	
 209 0040 0E0000EA 	Undef_HandlerR:  B       Undef_HandlerR
 210 0044 0F0000EA 	SWI_HandlerR:    B       SWI_HandlerR
 211 0048 100000EA 	PAbt_HandlerR:   B       PAbt_HandlerR
 212 004c 110000EA 	DAbt_HandlerR:   B       DAbt_HandlerR
 213 0050 120000EA 	IRQ_HandlerR:    B       IRQ_HandlerR
 214 0054 130000EA 	FIQ_HandlerR:    B       FIQ_HandlerR
 215              	
 216              	#endif /* VECTORS_IN_RAM && ROM_RUN */
 217              	
 218              	
 219              	
 220              	/*
 221              	 Exception Vectors 
 222              	 - for ROM_RUN: placed in 0x00000000 
 223              	 - for RAM_RUN: placed at 0x00200000 (on AT91SAM7S64)
 224              	 -> will be used during startup before remapping with target ROM_RUN
 225              	 -> will be used "always" in code without remapping or with target RAM_RUN
 226              	 Mapped to Address relative address 0 of .text
 227              	 Absolute addressing mode must be used.
 228              	 Dummy Handlers are implemented as infinite loops which can be modified.
 229              	*/
 230              				.text
 231              				.arm
 232              				.section .vectrom, "ax"
 233              	
 234 0000 18F09FE5 	Vectors:        LDR     PC,Reset_Addr         
 235 0004 18F09FE5 	                LDR     PC,Undef_Addr
 236 0008 18F09FE5 	                LDR     PC,SWI_Addr
 237 000c 18F09FE5 	                LDR     PC,PAbt_Addr
 238 0010 18F09FE5 	                LDR     PC,DAbt_Addr
 239 0014 0000A0E1 	                NOP                            /* Reserved Vector */
 240              	//                LDR     PC,IRQ_Addr
 241 0018 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_IVR */
 242              	//                LDR     PC,FIQ_Addr
 243 001c 20FF1FE5 	                LDR     PC,[PC,#-0xF20]        /* Vector From AIC_FVR */
 244              	
 245 0020 04000000 	Reset_Addr:     .word   Reset_Handler
 246 0024 40000000 	Undef_Addr:     .word   Undef_Handler
 247 0028 44000000 	SWI_Addr:       .word   SWI_Handler
 248 002c 48000000 	PAbt_Addr:      .word   PAbt_Handler
 249 0030 4C000000 	DAbt_Addr:      .word   DAbt_Handler
 250 0034 00000000 	                .word   0                      /* Reserved Address */
 251 0038 50000000 	IRQ_Addr:       .word   IRQ_Handler
 252 003c 54000000 	FIQ_Addr:       .word   FIQ_Handler
 253              	
 254 0040 0E0000EA 	Undef_Handler:  B       Undef_Handler
 255 0044 0F0000EA 	SWI_Handler:    B       SWI_Handler
 256 0048 100000EA 	PAbt_Handler:   B       PAbt_Handler
 257 004c 110000EA 	DAbt_Handler:   B       DAbt_Handler
 258 0050 120000EA 	IRQ_Handler:    B       IRQ_Handler
 259 0054 130000EA 	FIQ_Handler:    B       FIQ_Handler
 260              	
 261              	
 262              	// Starupt Code must be linked first at Address at which it expects to run.
 263              	
 264              			.text
 265              			.arm
 266              			.section .init, "ax"
 267              		
 268              			.global _startup
 269              			.func   _startup
 270              	_startup:
 271              	
 272              	
 273              	// Reset Handler
 274 0000 20F19FE5 	                LDR     pc, =Reset_Handler
 275              	Reset_Handler:
 276              	
 277              	// Setup EFC
 278              	.if EFC_SETUP
 279 0004 FF00E0E3 	                LDR     R0, =EFC_BASE
 280 0008 1C119FE5 	                LDR     R1, =EFC_FMR_Val
 281 000c 601080E5 	                STR     R1, [R0, #EFC_FMR]
 282              	.endif
 283              	
 284              	
 285              	// Setup WDT
 286              	.if WDT_SETUP
 287 0010 18019FE5 	                LDR     R0, =WDT_BASE
 288 0014 0219A0E3 	                LDR     R1, =WDT_MR_Val
 289 0018 041080E5 	                STR     R1, [R0, #WDT_MR]
 290              	.endif
 291              	
 292              	
 293              	// Setup PMC
 294              	.if PMC_SETUP
 295 001c 10019FE5 	                LDR     R0, =PMC_BASE
 296              	
 297              	//  Setup Main Oscillator
 298 0020 10119FE5 	                LDR     R1, =PMC_MOR_Val
 299 0024 201080E5 	                STR     R1, [R0, #PMC_MOR]
 300              	
 301              	//  Wait until Main Oscillator is stablilized
 302              	.if (PMC_MOR_Val & PMC_MOSCEN)
 303 0028 682090E5 	MOSCS_Loop:     LDR     R2, [R0, #PMC_SR]
 304 002c 012012E2 	                ANDS    R2, R2, #PMC_MOSCS
 305 0030 0800000A 	                BEQ     MOSCS_Loop
 306              	.endif
 307              	
 308              	//  Setup the PLL
 309              	.if (PMC_PLLR_Val & PMC_MUL)
 310 0034 00119FE5 	                LDR     R1, =PMC_PLLR_Val
 311 0038 2C1080E5 	                STR     R1, [R0, #PMC_PLLR]
 312              	
 313              	//  Wait until PLL is stabilized
 314 003c 682090E5 	PLL_Loop:       LDR     R2, [R0, #PMC_SR]
 315 0040 042012E2 	                ANDS    R2, R2, #PMC_LOCK
 316 0044 0D00000A 	                BEQ     PLL_Loop
 317              	.endif
 318              	
 319              	//  Select Clock
 320 0048 0710A0E3 	                LDR     R1, =PMC_MCKR_Val
 321 004c 301080E5 	                STR     R1, [R0, #PMC_MCKR]
 322              	.endif
 323              	
 324              	
 325              	// Setup Stack for each mode
 326              	
 327 0050 8109A0E3 	                LDR     R0, =Top_Stack
 328              	
 329              	//  Enter Undefined Instruction Mode and set its Stack Pointer
 330 0054 DBF021E3 	                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
 331 0058 00D0A0E1 	                MOV     SP, R0
 332 005c 040040E2 	                SUB     R0, R0, #UND_Stack_Size
 333              	
 334              	//  Enter Abort Mode and set its Stack Pointer
 335 0060 D7F021E3 	                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
 336 0064 00D0A0E1 	                MOV     SP, R0
 337 0068 040040E2 	                SUB     R0, R0, #ABT_Stack_Size
 338              	
 339              	//  Enter FIQ Mode and set its Stack Pointer
 340 006c D1F021E3 	                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
 341 0070 00D0A0E1 	                MOV     SP, R0
 342 0074 040040E2 	                SUB     R0, R0, #FIQ_Stack_Size
 343              	
 344              	//  Enter IRQ Mode and set its Stack Pointer
 345 0078 D2F021E3 	                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
 346 007c 00D0A0E1 	                MOV     SP, R0
 347 0080 010C40E2 	                SUB     R0, R0, #IRQ_Stack_Size
 348              	
 349              	//  Enter Supervisor Mode and set its Stack Pointer
 350 0084 D3F021E3 	                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
 351 0088 00D0A0E1 	                MOV     SP, R0
 352 008c 010C40E2 	                SUB     R0, R0, #SVC_Stack_Size
 353              	
 354              	//  Enter User Mode and set its Stack Pointer
 355 0090 10F021E3 	                MSR     CPSR_c, #Mode_USR
 356 0094 00D0A0E1 	                MOV     SP, R0
 357              	
 358              	// Setup a default Stack Limit (when compiled with "-mapcs-stack-check")
 359 0098 01AB4DE2 	                SUB     SL, SP, #USR_Stack_Size
 360              	
 361              	#ifdef ROM_RUN
 362              	// Relocate .data section (Copy from ROM to RAM)
 363 009c 9C109FE5 	                LDR     R1, =_etext
 364 00a0 9C209FE5 	                LDR     R2, =_data
 365 00a4 9C309FE5 	                LDR     R3, =_edata
 366 00a8 030052E1 	LoopRel:        CMP     R2, R3
 367 00ac 04009134 	                LDRLO   R0, [R1], #4
 368 00b0 04008234 	                STRLO   R0, [R2], #4
 369 00b4 2800003A 	                BLO     LoopRel
 370              	#endif
 371              	
 372              	// Clear .bss section (Zero init)
 373 00b8 0000A0E3 	                MOV     R0, #0
 374 00bc 88109FE5 	                LDR     R1, =__bss_start__
 375 00c0 88209FE5 	                LDR     R2, =__bss_end__
 376 00c4 020051E1 	LoopZI:         CMP     R1, R2
 377 00c8 04008134 	                STRLO   R0, [R1], #4
 378 00cc 2F00003A 	                BLO     LoopZI
 379              	
 380              	
 381              	#if defined(VECTORS_IN_RAM) || defined(RAM_RUN)
 382              	/* 
 383              	   *** Remap ***
 384              	   ROM_RUN: exception vectors for RAM have been already copied 
 385              	     to 0x00200000 by the .data copy-loop 
 386              	   RAM_RUN: exception vectors are already placed at 0x0020000 by
 387              	     linker settings
 388              	*/
 389              					.equ    MC_BASE,0xFFFFFF00  /* MC Base Address */
 390              					.equ    MC_RCR, 0x00        /* MC_RCR Offset */
 391              	
 392 00d0 FF00E0E3 					LDR     R0, =MC_BASE
 393 00d4 0110A0E3 					MOV     R1, #1
 394 00d8 001080E5 					STR     R1, [R0, #MC_RCR]   // Remap
 395              	#endif /* VECTORS_IN_RAM || RAM_RUN */
 396              	
 397              	
 398              	/*
 399              	   Call C++ constructors (for objects in "global scope")
 400              	   added by Martin Thomas based on a Anglia Design 
 401              	   example-application for STR7 ARM
 402              	*/
 403              	
 404 00dc 70009FE5 				LDR 	r0, =__ctors_start__
 405 00e0 70109FE5 				LDR 	r1, =__ctors_end__
 406              	ctor_loop:
 407 00e4 010050E1 				CMP 	r0, r1
 408 00e8 3F00000A 				BEQ 	ctor_end
 409 00ec 042090E4 				LDR 	r2, [r0], #4   /* this ctor's address */
 410 00f0 03002DE9 				STMFD 	sp!, {r0-r1}   /* save loop counters  */
 411 00f4 0FE0A0E1 				MOV 	lr, pc         /* set return address  */
 412              	//			MOV 	pc, r2
 413 00f8 12FF2FE1 				BX      r2             /* call ctor */
 414 00fc 0300BDE8 				LDMFD 	sp!, {r0-r1}   /* restore loop counters */
 415 0100 370000EA 				B 		ctor_loop
 416              	ctor_end:
 417              	
 418              	       
 419              	// Enter the C code
 420 0104 0000A0E3 					mov   r0,#0            // no arguments (argc = 0)
 421 0108 0010A0E1 					mov   r1,r0
 422 010c 0020A0E1 					mov   r2,r0
 423 0110 00B0A0E1 					mov   fp,r0            // null frame pointer
 424 0114 0070A0E1 					mov   r7,r0            // null frame pointer for thumb
 425 0118 3CA09FE5 					ldr   r10,=main
 426 011c 00E08FE2 					adr   lr, __main_exit
 427 0120 1AFF2FE1 					bx    r10              // enter main()
 428              	
 429 0124 470000EA 	__main_exit:    B       __main_exit
 430              	
 431              	
 433              					.endfunc
 434              	
 435 0128 04000000 	.end
 435      00013200 
 435      40FDFFFF 
 435      00FCFFFF 
 435      01060000 
DEFINED SYMBOLS
                            *ABS*:00000000 startup_SAM7S.S
     startup_SAM7S.S:38     *ABS*:00000010 Mode_USR
     startup_SAM7S.S:39     *ABS*:00000011 Mode_FIQ
     startup_SAM7S.S:40     *ABS*:00000012 Mode_IRQ
     startup_SAM7S.S:41     *ABS*:00000013 Mode_SVC
     startup_SAM7S.S:42     *ABS*:00000017 Mode_ABT
     startup_SAM7S.S:43     *ABS*:0000001b Mode_UND
     startup_SAM7S.S:44     *ABS*:0000001f Mode_SYS
     startup_SAM7S.S:46     *ABS*:00000080 I_Bit
     startup_SAM7S.S:47     *ABS*:00000040 F_Bit
     startup_SAM7S.S:51     *ABS*:00100000 FLASH_BASE
     startup_SAM7S.S:52     *ABS*:00200000 RAM_BASE
     startup_SAM7S.S:68     *ABS*:00204000 Top_Stack
     startup_SAM7S.S:69     *ABS*:00000004 UND_Stack_Size
     startup_SAM7S.S:70     *ABS*:00000100 SVC_Stack_Size
     startup_SAM7S.S:71     *ABS*:00000004 ABT_Stack_Size
     startup_SAM7S.S:72     *ABS*:00000004 FIQ_Stack_Size
     startup_SAM7S.S:73     *ABS*:00000100 IRQ_Stack_Size
     startup_SAM7S.S:74     *ABS*:00000400 USR_Stack_Size
     startup_SAM7S.S:78     *ABS*:ffffff00 EFC_BASE
     startup_SAM7S.S:79     *ABS*:00000060 EFC_FMR
     startup_SAM7S.S:92     *ABS*:00000001 EFC_SETUP
     startup_SAM7S.S:93     *ABS*:00320100 EFC_FMR_Val
     startup_SAM7S.S:97     *ABS*:fffffd40 WDT_BASE
     startup_SAM7S.S:98     *ABS*:00000004 WDT_MR
     startup_SAM7S.S:112    *ABS*:00000001 WDT_SETUP
     startup_SAM7S.S:113    *ABS*:00008000 WDT_MR_Val
     startup_SAM7S.S:117    *ABS*:fffffc00 PMC_BASE
     startup_SAM7S.S:118    *ABS*:00000020 PMC_MOR
     startup_SAM7S.S:119    *ABS*:00000024 PMC_MCFR
     startup_SAM7S.S:120    *ABS*:0000002c PMC_PLLR
     startup_SAM7S.S:121    *ABS*:00000030 PMC_MCKR
     startup_SAM7S.S:122    *ABS*:00000068 PMC_SR
     startup_SAM7S.S:123    *ABS*:00000001 PMC_MOSCEN
     startup_SAM7S.S:124    *ABS*:00000002 PMC_OSCBYPASS
     startup_SAM7S.S:125    *ABS*:0000ff00 PMC_OSCOUNT
     startup_SAM7S.S:126    *ABS*:000000ff PMC_DIV
     startup_SAM7S.S:127    *ABS*:00003f00 PMC_PLLCOUNT
     startup_SAM7S.S:128    *ABS*:0000c000 PMC_OUT
     startup_SAM7S.S:129    *ABS*:07ff0000 PMC_MUL
     startup_SAM7S.S:130    *ABS*:30000000 PMC_USBDIV
     startup_SAM7S.S:131    *ABS*:00000003 PMC_CSS
     startup_SAM7S.S:132    *ABS*:0000001c PMC_PRES
     startup_SAM7S.S:133    *ABS*:00000001 PMC_MOSCS
     startup_SAM7S.S:134    *ABS*:00000004 PMC_LOCK
     startup_SAM7S.S:167    *ABS*:00000001 PMC_SETUP
     startup_SAM7S.S:168    *ABS*:00000601 PMC_MOR_Val
     startup_SAM7S.S:169    *ABS*:00191c05 PMC_PLLR_Val
     startup_SAM7S.S:170    *ABS*:00000007 PMC_MCKR_Val
     startup_SAM7S.S:187    .text:00000000 $a
     startup_SAM7S.S:190    .vectram:00000000 VectorsRAM
     startup_SAM7S.S:190    .vectram:00000000 $a
     startup_SAM7S.S:199    .vectram:00000020 Reset_AddrR
     startup_SAM7S.S:200    .vectram:00000024 Undef_AddrR
     startup_SAM7S.S:201    .vectram:00000028 SWI_AddrR
     startup_SAM7S.S:202    .vectram:0000002c PAbt_AddrR
     startup_SAM7S.S:203    .vectram:00000030 DAbt_AddrR
     startup_SAM7S.S:199    .vectram:00000020 $d
     startup_SAM7S.S:275    .init:00000004 Reset_Handler
     startup_SAM7S.S:209    .vectram:00000040 Undef_HandlerR
     startup_SAM7S.S:210    .vectram:00000044 SWI_HandlerR
     startup_SAM7S.S:211    .vectram:00000048 PAbt_HandlerR
     startup_SAM7S.S:212    .vectram:0000004c DAbt_HandlerR
     startup_SAM7S.S:206    .vectram:00000038 IRQ_AddrR
     startup_SAM7S.S:213    .vectram:00000050 IRQ_HandlerR
     startup_SAM7S.S:207    .vectram:0000003c FIQ_AddrR
     startup_SAM7S.S:214    .vectram:00000054 FIQ_HandlerR
     startup_SAM7S.S:209    .vectram:00000040 $a
     startup_SAM7S.S:234    .vectrom:00000000 Vectors
     startup_SAM7S.S:234    .vectrom:00000000 $a
     startup_SAM7S.S:245    .vectrom:00000020 Reset_Addr
     startup_SAM7S.S:246    .vectrom:00000024 Undef_Addr
     startup_SAM7S.S:247    .vectrom:00000028 SWI_Addr
     startup_SAM7S.S:248    .vectrom:0000002c PAbt_Addr
     startup_SAM7S.S:249    .vectrom:00000030 DAbt_Addr
     startup_SAM7S.S:245    .vectrom:00000020 $d
     startup_SAM7S.S:254    .vectrom:00000040 Undef_Handler
     startup_SAM7S.S:255    .vectrom:00000044 SWI_Handler
     startup_SAM7S.S:256    .vectrom:00000048 PAbt_Handler
     startup_SAM7S.S:257    .vectrom:0000004c DAbt_Handler
     startup_SAM7S.S:251    .vectrom:00000038 IRQ_Addr
     startup_SAM7S.S:258    .vectrom:00000050 IRQ_Handler
     startup_SAM7S.S:252    .vectrom:0000003c FIQ_Addr
     startup_SAM7S.S:259    .vectrom:00000054 FIQ_Handler
     startup_SAM7S.S:254    .vectrom:00000040 $a
     startup_SAM7S.S:270    .init:00000000 _startup
     startup_SAM7S.S:274    .init:00000000 $a
     startup_SAM7S.S:303    .init:00000028 MOSCS_Loop
     startup_SAM7S.S:314    .init:0000003c PLL_Loop
     startup_SAM7S.S:366    .init:000000a8 LoopRel
     startup_SAM7S.S:376    .init:000000c4 LoopZI
     startup_SAM7S.S:389    *ABS*:ffffff00 MC_BASE
     startup_SAM7S.S:390    *ABS*:00000000 MC_RCR
     startup_SAM7S.S:406    .init:000000e4 ctor_loop
     startup_SAM7S.S:416    .init:00000104 ctor_end
     startup_SAM7S.S:429    .init:00000124 __main_exit
     startup_SAM7S.S:435    .init:00000128 $d

UNDEFINED SYMBOLS
_etext
_data
_edata
__bss_start__
__bss_end__
__ctors_start__
__ctors_end__
main
